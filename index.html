<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1020" />
  <title>Meditation Timer</title>
  <style>
    :root{
      --bg0:#070a14;
      --bg1:#0b1020;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius: 22px;
    }

    * { box-sizing: border-box; }
    body{
      margin:0;
      min-height:100vh;
      color:var(--text);
      background:
        radial-gradient(900px 500px at 20% 15%, rgba(167,139,250,.22), transparent 55%),
        radial-gradient(900px 500px at 75% 25%, rgba(125,211,252,.18), transparent 55%),
        radial-gradient(900px 700px at 50% 120%, rgba(134,239,172,.10), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", system-ui, "Segoe UI", Roboto, Helvetica, Arial;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 22px 14px;
    }

    .app{
      width: min(520px, 100%);
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    .hero{
      padding: 18px 18px 14px;
      border-radius: var(--radius);
      background: linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.08);
      overflow:hidden;
      position:relative;
    }

    .hero::before{
      content:"";
      position:absolute;
      inset:-1px;
      background:
        radial-gradient(220px 220px at 20% 30%, rgba(125,211,252,.14), transparent 60%),
        radial-gradient(260px 260px at 80% 0%, rgba(167,139,250,.16), transparent 60%);
      pointer-events:none;
    }

    .title{
      position:relative;
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 10px;
    }

    h1{
      margin:0;
      font-size: 22px;
      letter-spacing: .2px;
      font-weight: 680;
    }

    .badge{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .bigtime{
      position:relative;
      margin-top: 14px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: 10px;
    }

    .clock{
      font-variant-numeric: tabular-nums;
      font-size: 44px;
      line-height: 1;
      font-weight: 760;
      letter-spacing: .5px;
    }
    .sub{
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    .ringWrap{
      position:relative;
      width: 92px;
      height: 92px;
      flex: 0 0 auto;
    }
    svg{ display:block; }
    .ringText{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      font-size: 12px;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }

    .panel{
      padding: 16px 16px 14px;
      border-radius: var(--radius);
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.07);
      box-shadow: 0 10px 35px rgba(0,0,0,.35);
    }

    .row{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    label{
      font-size: 13px;
      color: var(--muted);
    }

    .selectWrap{
      display:flex;
      align-items:center;
      gap: 10px;
      width: 100%;
      justify-content:space-between;
    }

    select{
      appearance:none;
      -webkit-appearance:none;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.07);
      color:var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 16px;
      outline:none;
      width: 160px;
      color-scheme: dark;
    }
    option { background: #0b1020; color: rgba(255,255,255,.92); }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    .buttons{
      display:flex;
      gap: 10px;
      margin-top: 12px;
    }

    button{
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.07);
      color:var(--text);
      padding: 12px 14px;
      border-radius: 16px;
      font-size: 16px;
      font-weight: 650;
      outline:none;
      width: 100%;
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      transition: transform .06s ease, opacity .2s ease, filter .2s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px) scale(.995); }
    button.primary{
      background: linear-gradient(135deg, rgba(125,211,252,.25), rgba(167,139,250,.20));
      border-color: rgba(125,211,252,.35);
    }
    button.warn{
      background: linear-gradient(135deg, rgba(253,164,175,.18), rgba(167,139,250,.12));
      border-color: rgba(253,164,175,.30);
    }
    button:disabled{
      opacity:.45;
      filter: saturate(.6);
      transform:none !important;
    }

    .timeline{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .chipRow{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .chip{
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }
    .chip strong{ color: var(--text); font-weight: 650; }
    .chip.active{
      border-color: rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
      color: rgba(255,255,255,.82);
    }

    .footer{
      text-align:center;
      font-size: 12px;
      color: rgba(255,255,255,.55);
      margin-top: 2px;
    }
    .mono{ font-variant-numeric: tabular-nums; }
  </style>
</head>

<body>
  <div class="app" role="application" aria-label="Meditation timer">
    <div class="hero">
      <div class="title">
        <h1>Meditation Timer</h1>
        <div class="badge" id="statusBadge">Ready</div>
      </div>

      <div class="bigtime">
        <div>
          <div class="clock" id="timeLeft">30:00</div>
          <div class="sub" id="stageLabel">Bell at start · Beeps along the way · Bell at end</div>
        </div>

        <div class="ringWrap" aria-hidden="true">
          <svg width="92" height="92" viewBox="0 0 92 92">
            <defs>
              <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="2.5" result="blur"/>
                <feMerge>
                  <feMergeNode in="blur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <circle cx="46" cy="46" r="36" stroke="rgba(255,255,255,.10)" stroke-width="10" fill="none"></circle>
            <circle id="ring" cx="46" cy="46" r="36"
              stroke="rgba(125,211,252,.85)" stroke-width="10" fill="none"
              stroke-linecap="round"
              transform="rotate(-90 46 46)"
              filter="url(#softGlow)"
            ></circle>
          </svg>
          <div class="ringText"><span id="pct">0%</span></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <div class="selectWrap">
          <div>
            <label for="minutes">Total time</label>
            <div class="hint">Stage beeps scale proportionally from the 30-minute template.</div>
          </div>

          <select id="minutes" aria-label="Total meditation time in minutes">
            <option value="5">5 min</option>
            <option value="10">10 min</option>
            <option value="15">15 min</option>
            <option value="20">20 min</option>
            <option value="25">25 min</option>
            <option value="30" selected>30 min</option>
            <option value="35">35 min</option>
            <option value="40">40 min</option>
            <option value="45">45 min</option>
            <option value="50">50 min</option>
            <option value="55">55 min</option>
            <option value="60">60 min</option>
          </select>
        </div>
      </div>

      <div class="buttons">
        <button class="primary" id="startBtn">Start</button>
        <button class="warn" id="stopBtn" disabled>Stop</button>
      </div>

      <div class="timeline" aria-label="Timeline cues">
        <label>Upcoming cues</label>
        <div class="chipRow" id="chips"></div>
      </div>
    </div>

    <div class="footer">
      Tip: in Safari, Share → <span class="mono">Add to Home Screen</span> for a full-screen feel.
    </div>
  </div>

<script>
(() => {
  // 30-min template
  const TEMPLATE_TOTAL_MIN = 30;
  const templateCues = [
    { tMin: 0,  kind: "bell",   label: "Start bell" },
    { tMin: 3,  kind: "beep",   label: "Stage shift" },
    { tMin: 8,  kind: "beep",   label: "Stage shift" },
    { tMin: 13, kind: "beep",   label: "Stage shift" },
    { tMin: 18, kind: "beep",   label: "Stage shift" },
    { tMin: 27, kind: "double", label: "Two beeps" },
    { tMin: 30, kind: "bell",   label: "End bell" },
  ];

  // UI
  const minutesSel  = document.getElementById("minutes");
  const startBtn    = document.getElementById("startBtn");
  const stopBtn     = document.getElementById("stopBtn");
  const timeLeftEl  = document.getElementById("timeLeft");
  const statusBadge = document.getElementById("statusBadge");
  const stageLabel  = document.getElementById("stageLabel");
  const ring        = document.getElementById("ring");
  const pctEl       = document.getElementById("pct");
  const chipsEl     = document.getElementById("chips");

  // Ring
  const R = 36;
  const CIRC = 2 * Math.PI * R;
  ring.style.strokeDasharray = `${CIRC} ${CIRC}`;
  ring.style.strokeDashoffset = `${CIRC}`;
  function setProgress(p) {
    const clamped = Math.min(1, Math.max(0, p));
    ring.style.strokeDashoffset = String(CIRC * (1 - clamped));
    pctEl.textContent = `${Math.round(clamped * 100)}%`;
  }

  function mmss(totalSeconds) {
    const s = Math.max(0, Math.floor(totalSeconds));
    const mm = Math.floor(s / 60);
    const ss = s % 60;
    return `${String(mm).padStart(2,"0")}:${String(ss).padStart(2,"0")}`;
  }
  function formatCueTime(secondsFromStart) { return `+${mmss(secondsFromStart)}`; }
  function setStatus(text) { statusBadge.textContent = text; }

  // State
  let state = "idle"; // idle | running
  let totalSec = 30 * 60;
  let startPerf = 0;
  let rafId = 0;
  let cueTimeouts = [];
  let cuesScaled = [];
  let nextCueIndex = 0;

  // Wake Lock
  let wakeLockSentinel = null;
  async function requestWakeLock() {
    try {
      if (!("wakeLock" in navigator)) return false;
      wakeLockSentinel = await navigator.wakeLock.request("screen");
      return true;
    } catch {
      wakeLockSentinel = null;
      return false;
    }
  }
  async function releaseWakeLock() {
    try { if (wakeLockSentinel) await wakeLockSentinel.release(); } catch {}
    wakeLockSentinel = null;
  }

  // WebAudio
  let audioCtx = null;
  let master = null;

  function ensureAudio() {
    if (!audioCtx || audioCtx.state === "closed") {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = null;
    }
    if (!master) {
      master = audioCtx.createGain();
      master.gain.value = 0.95;
      master.connect(audioCtx.destination);
    }
  }

  // Prime audio (call early in the gesture). No sound, just “unlock”.
  function primeAudio() {
    try {
      ensureAudio();
      audioCtx.resume(); // intentionally not awaited
      const buffer = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      src.connect(audioCtx.destination);
      src.start(0);
      src.stop(0);
    } catch {}
  }

  // Try resuming repeatedly (helps iOS web-app flip to running)
  function resumeBurst() {
    if (!audioCtx) return;
    for (let i = 0; i < 12; i++) {
      setTimeout(() => { try { audioCtx.resume(); } catch {} }, i * 60);
    }
  }

  function canPlayNow() {
    ensureAudio();
    if (audioCtx.state !== "running") {
      try { audioCtx.resume(); } catch {}
    }
    return audioCtx.state === "running";
  }

  // Beep: louder + ~0.70s
  function playBeep() {
    if (!canPlayNow()) return false;
    const now = audioCtx.currentTime;

    const osc  = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = "sine";
    osc.frequency.setValueAtTime(880, now);

    const peak = 0.22;
    const attack = 0.03;
    const holdUntil = 0.15;
    const decayEnd = 0.63;
    const stopAt = 0.70;

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(peak, now + attack);
    gain.gain.setValueAtTime(peak, now + holdUntil);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + decayEnd);

    osc.connect(gain);
    gain.connect(master);

    osc.start(now);
    osc.stop(now + stopAt);
    return true;
  }

  // Bell: longer + brighter
  function playBell() {
    if (!canPlayNow()) return false;
    const now = audioCtx.currentTime;

    const mix = audioCtx.createGain();
    mix.gain.value = 1.0;
    mix.connect(master);

    const base = 528;
    const ratios = [1.0, 2.0, 2.76, 3.12, 4.20, 5.40];
    const amps   = [0.16, 0.10, 0.08, 0.055, 0.040, 0.030];
    const decays = [5.2, 4.3, 3.7, 3.2, 2.8, 2.4];

    ratios.forEach((r, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = (i >= 2) ? "triangle" : "sine";
      osc.frequency.setValueAtTime(base * r, now);
      osc.detune.setValueAtTime((Math.random() * 10) - 5, now);

      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(amps[i], now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + decays[i]);

      osc.connect(gain);
      gain.connect(mix);

      osc.start(now);
      osc.stop(now + decays[i] + 0.12);
    });

    // slight strike noise
    const noiseDur = 0.45;
    const bufferSize = Math.floor(audioCtx.sampleRate * noiseDur);
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.06;

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    const nGain = audioCtx.createGain();
    nGain.gain.setValueAtTime(0.0001, now);
    nGain.gain.exponentialRampToValueAtTime(0.03, now + 0.012);
    nGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);

    noise.connect(nGain);
    nGain.connect(master);
    noise.start(now);
    noise.stop(now + noiseDur);

    return true;
  }

  // Retry that ALSO keeps trying resume()
  function playWithRetry(kind, tries = 12, gapMs = 90) {
    if (state !== "running") return;

    // Keep nudging resume
    try { if (audioCtx && audioCtx.state !== "running") audioCtx.resume(); } catch {}

    let ok = false;
    if (kind === "bell") ok = playBell();
    else ok = playBeep();

    if (!ok && tries > 0) setTimeout(() => playWithRetry(kind, tries - 1, gapMs), gapMs);
  }

  function playDoubleBeep() {
    playWithRetry("beep");
    setTimeout(() => playWithRetry("beep"), 900);
  }

  // Cues
  function clearCues() {
    cueTimeouts.forEach(id => clearTimeout(id));
    cueTimeouts = [];
    nextCueIndex = 0;
  }

  function computeScaledCues(selectedMinutes) {
    const scale = selectedMinutes / TEMPLATE_TOTAL_MIN;
    const cues = templateCues.map(c => ({
      tSec: Math.round(c.tMin * 60 * scale),
      kind: c.kind,
      label: c.label
    }));
    cues[0].tSec = 0;
    cues[cues.length - 1].tSec = selectedMinutes * 60;
    for (let i = 1; i < cues.length; i++) {
      if (cues[i].tSec <= cues[i - 1].tSec) cues[i].tSec = cues[i - 1].tSec + 1;
    }
    cues[cues.length - 1].tSec = selectedMinutes * 60;
    return cues;
  }

  function renderChips(elapsedSec = 0) {
    chipsEl.innerHTML = "";

    let activeIdx = nextCueIndex;
    while (activeIdx < cuesScaled.length && cuesScaled[activeIdx].tSec <= elapsedSec + 0.02) activeIdx++;

    cuesScaled.forEach((c, idx) => {
      const div = document.createElement("div");
      const isActive = (idx === activeIdx && state === "running");
      div.className = "chip" + (isActive ? " active" : "");
      const kindText = c.kind === "bell" ? "Bell" : (c.kind === "double" ? "Two beeps" : "Beep");
      div.innerHTML = `<strong>${kindText}</strong> · ${formatCueTime(c.tSec)}`;
      chipsEl.appendChild(div);
    });
  }

  function setButtons() {
    const running = state === "running";
    startBtn.disabled = running;
    stopBtn.disabled = !running;
    minutesSel.disabled = running;
  }

  function scheduleCues() {
    clearCues();
    nextCueIndex = 0;

    // skip index 0 because we fire start bell manually
    for (let idx = 1; idx < cuesScaled.length; idx++) {
      const cue = cuesScaled[idx];
      const delayMs = Math.max(0, cue.tSec * 1000);

      const id = setTimeout(() => {
        if (state !== "running") return;

        stageLabel.textContent = cue.label;

        if (cue.kind === "bell") playWithRetry("bell");
        else if (cue.kind === "double") playDoubleBeep();
        else playWithRetry("beep");

        nextCueIndex = Math.min(cuesScaled.length, idx + 1);
        const elapsed = (performance.now() - startPerf) / 1000;
        renderChips(elapsed);

        if (cue.tSec >= totalSec) finish();
      }, delayMs);

      cueTimeouts.push(id);
    }

    renderChips(0);
  }

  function tickUI() {
    const elapsedSec = (performance.now() - startPerf) / 1000;
    const remaining = totalSec - elapsedSec;

    timeLeftEl.textContent = mmss(remaining);
    setProgress(elapsedSec / totalSec);
    renderChips(elapsedSec);

    if (state === "running") rafId = requestAnimationFrame(tickUI);
  }

  function start() {
    // Make UI start immediately even if audio is slow to wake
    setStatus("Starting…");

    primeAudio();     // gesture-sensitive
    resumeBurst();    // extra nudges

    const selectedMinutes = parseInt(minutesSel.value, 10);
    totalSec = selectedMinutes * 60;
    cuesScaled = computeScaledCues(selectedMinutes);

    state = "running";
    startPerf = performance.now();
    setStatus("Meditating");
    stageLabel.textContent = "Start bell";
    setButtons();

    // request wake lock AFTER we prime audio
    requestWakeLock().catch(() => {});

    // start bell with retries
    playWithRetry("bell", 14, 80);

    scheduleCues();

    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tickUI);
  }

  function stop() {
    clearCues();
    cancelAnimationFrame(rafId);
    releaseWakeLock().catch(() => {});

    state = "idle";
    setStatus("Ready");
    stageLabel.textContent = "Bell at start · Beeps along the way · Bell at end";
    setButtons();
    setProgress(0);

    const selectedMinutes = parseInt(minutesSel.value, 10);
    totalSec = selectedMinutes * 60;
    timeLeftEl.textContent = mmss(totalSec);

    cuesScaled = computeScaledCues(selectedMinutes);
    nextCueIndex = 0;
    renderChips(0);
  }

  function finish() {
    clearCues();
    cancelAnimationFrame(rafId);
    releaseWakeLock().catch(() => {});

    // UI polish: Start enabled, Stop disabled
    state = "idle";
    setStatus("Done");
    stageLabel.textContent = "Session complete";
    timeLeftEl.textContent = "00:00";
    setProgress(1);
    setButtons();
  }

  function init() {
    const selectedMinutes = parseInt(minutesSel.value, 10);
    totalSec = selectedMinutes * 60;
    cuesScaled = computeScaledCues(selectedMinutes);
    timeLeftEl.textContent = mmss(totalSec);
    setProgress(0);
    renderChips(0);
    setButtons();
  }

  // Events
  let lastStartAt = 0;
  function startOnce() {
    const now = Date.now();
    if (now - lastStartAt < 700) return; // avoid touchend+click double fire
    lastStartAt = now;
    if (state === "running") return;
    start();
  }

  // Prime on earliest gesture
  startBtn.addEventListener("touchstart", primeAudio, { passive: true });
  startBtn.addEventListener("mousedown", primeAudio, { passive: true });

  startBtn.addEventListener("touchend", () => startOnce(), { passive: true });
  startBtn.addEventListener("click", () => startOnce());

  stopBtn.addEventListener("click", () => stop());

  minutesSel.addEventListener("change", () => {
    if (state !== "idle") return;
    init();
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      wakeLockSentinel = null;
      return;
    }
    if (state === "running" && !wakeLockSentinel) requestWakeLock().catch(() => {});
    if (audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
  });

  init();
})();
</script>
</body>
</html>
