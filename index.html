<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1020" />
  <title>Meditation Timer</title>
  <style>
    :root{
      --bg0:#070a14;
      --bg1:#0b1020;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius: 22px;
    }

    * { box-sizing: border-box; }
    body{
      margin:0;
      min-height:100vh;
      color:var(--text);
      background:
        radial-gradient(900px 500px at 20% 15%, rgba(167,139,250,.22), transparent 55%),
        radial-gradient(900px 500px at 75% 25%, rgba(125,211,252,.18), transparent 55%),
        radial-gradient(900px 700px at 50% 120%, rgba(134,239,172,.10), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", system-ui, "Segoe UI", Roboto, Helvetica, Arial;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 22px 14px;
    }

    .app{
      width: min(520px, 100%);
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    .hero{
      padding: 18px 18px 14px;
      border-radius: var(--radius);
      background: linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.08);
      overflow:hidden;
      position:relative;
    }

    .hero::before{
      content:"";
      position:absolute;
      inset:-1px;
      background:
        radial-gradient(220px 220px at 20% 30%, rgba(125,211,252,.14), transparent 60%),
        radial-gradient(260px 260px at 80% 0%, rgba(167,139,250,.16), transparent 60%);
      pointer-events:none;
    }

    .title{
      position:relative;
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 10px;
    }

    h1{
      margin:0;
      font-size: 22px;
      letter-spacing: .2px;
      font-weight: 680;
    }

    .badge{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .bigtime{
      position:relative;
      margin-top: 14px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: 10px;
    }

    .clock{
      font-variant-numeric: tabular-nums;
      font-size: 44px;
      line-height: 1;
      font-weight: 760;
      letter-spacing: .5px;
    }
    .sub{
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    .ringWrap{
      position:relative;
      width: 92px;
      height: 92px;
      flex: 0 0 auto;
    }
    svg{ display:block; }
    .ringText{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      font-size: 12px;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }

    .panel{
      padding: 16px 16px 14px;
      border-radius: var(--radius);
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.07);
      box-shadow: 0 10px 35px rgba(0,0,0,.35);
    }

    .row{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    label{
      font-size: 13px;
      color: var(--muted);
    }

    .selectWrap{
      display:flex;
      align-items:center;
      gap: 10px;
      width: 100%;
      justify-content:space-between;
    }

    select{
      appearance:none;
      -webkit-appearance:none;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.07);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 16px;
      outline:none;
      width: 160px;
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    .buttons{
      display:flex;
      gap: 10px;
      margin-top: 12px;
    }

    button{
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.07);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 16px;
      font-size: 16px;
      font-weight: 650;
      outline:none;
      width: 100%;
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      transition: transform .06s ease, opacity .2s ease;
      -webkit-tap-highlight-color: transparent;
    }
    button:active{ transform: translateY(1px) scale(.995); }
    button.primary{
      background: linear-gradient(135deg, rgba(125,211,252,.25), rgba(167,139,250,.20));
      border-color: rgba(125,211,252,.35);
    }
    button.warn{
      background: linear-gradient(135deg, rgba(253,164,175,.18), rgba(167,139,250,.12));
      border-color: rgba(253,164,175,.30);
    }
    button:disabled{ opacity:.55; transform:none !important; }

    .timeline{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }

    .chipRow{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .chip{
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }
    .chip strong{ color: var(--text); font-weight: 650; }
    .chip.active{
      border-color: rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
      color: rgba(255,255,255,.82);
    }

    .footer{
      text-align:center;
      font-size: 12px;
      color: rgba(255,255,255,.55);
      margin-top: 2px;
    }
    .mono{ font-variant-numeric: tabular-nums; }
  </style>
</head>

<body>
  <div class="app" role="application" aria-label="Meditation timer">
    <div class="hero">
      <div class="title">
        <h1>Meditation Timer</h1>
        <div class="badge" id="statusBadge">Ready</div>
      </div>

      <div class="bigtime">
        <div>
          <div class="clock" id="timeLeft">30:00</div>
          <div class="sub" id="stageLabel">Bell at start · Beeps along the way · Bell at end</div>
        </div>

        <div class="ringWrap" aria-hidden="true">
          <svg width="92" height="92" viewBox="0 0 92 92">
            <defs>
              <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="2.5" result="blur"/>
                <feMerge>
                  <feMergeNode in="blur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <circle cx="46" cy="46" r="36" stroke="rgba(255,255,255,.10)" stroke-width="10" fill="none"></circle>
            <circle id="ring" cx="46" cy="46" r="36"
              stroke="rgba(125,211,252,.85)" stroke-width="10" fill="none"
              stroke-linecap="round"
              transform="rotate(-90 46 46)"
              filter="url(#softGlow)"
            ></circle>
          </svg>
          <div class="ringText"><span id="pct">0%</span></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <div class="selectWrap">
          <div>
            <label for="minutes">Total time</label>
            <div class="hint">Stage beeps scale proportionally from the 30-minute template.</div>
          </div>
          <select id="minutes" aria-label="Total meditation time in minutes"></select>
        </div>
      </div>

      <div class="buttons">
        <button class="primary" id="startBtn">Start</button>
        <button class="warn" id="stopBtn" disabled>Stop</button>
      </div>

      <div class="timeline" aria-label="Timeline cues">
        <label>Upcoming cues</label>
        <div class="chipRow" id="chips"></div>
      </div>
    </div>

    <div class="footer">
      Tip: on iPhone Safari, use Share → <span class="mono">Add to Home Screen</span> for a full-screen feel.
    </div>
  </div>

<script>
(() => {
  // ---- Template timings (minutes) for a 30-minute sit ----
  const TEMPLATE_TOTAL_MIN = 30;
  const templateCues = [
    { tMin: 0,  kind: "bell",  label: "Start bell" },
    { tMin: 3,  kind: "beep",  label: "Stage shift" },
    { tMin: 8,  kind: "beep",  label: "Stage shift" },
    { tMin: 13, kind: "beep",  label: "Stage shift" },
    { tMin: 18, kind: "beep",  label: "Stage shift" },
    { tMin: 27, kind: "double",label: "Two beeps" },
    { tMin: 30, kind: "bell",  label: "End bell" },
  ];

  // ---- UI elements ----
  const minutesSel = document.getElementById("minutes");
  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");
  const timeLeftEl = document.getElementById("timeLeft");
  const statusBadge = document.getElementById("statusBadge");
  const stageLabel = document.getElementById("stageLabel");
  const ring = document.getElementById("ring");
  const pctEl = document.getElementById("pct");
  const chipsEl = document.getElementById("chips");

  // Populate 5..60 minutes in increments of 5
  for (let m = 5; m <= 60; m += 5) {
    const opt = document.createElement("option");
    opt.value = String(m);
    opt.textContent = `${m} min`;
    minutesSel.appendChild(opt);
  }
  minutesSel.value = "30";

  // ---- Progress ring ----
  const R = 36;
  const CIRC = 2 * Math.PI * R;
  ring.style.strokeDasharray = `${CIRC} ${CIRC}`;
  ring.style.strokeDashoffset = `${CIRC}`;

  function setProgress(p) {
    const clamped = Math.min(1, Math.max(0, p));
    ring.style.strokeDashoffset = String(CIRC * (1 - clamped));
    pctEl.textContent = `${Math.round(clamped * 100)}%`;
  }

  function mmss(totalSeconds) {
    const s = Math.max(0, Math.floor(totalSeconds));
    const mm = Math.floor(s / 60);
    const ss = s % 60;
    return `${String(mm).padStart(2,"0")}:${String(ss).padStart(2,"0")}`;
  }

  function formatCueTime(secondsFromStart) {
    return `+${mmss(secondsFromStart)}`;
  }

  // ---- Web Audio (no files) ----
  let audioCtx = null;

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function masterGain() {
    const g = audioCtx.createGain();
    g.gain.value = 0.95;
    g.connect(audioCtx.destination);
    return g;
  }

  // Longer single beep (still unobtrusive)
  function playBeep() {
    ensureAudio();
    const now = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const out = masterGain();

    osc.type = "sine";
    osc.frequency.setValueAtTime(880, now);

    // Envelope: gentle attack + longer decay
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.42);

    osc.connect(gain);
    gain.connect(out);

    osc.start(now);
    osc.stop(now + 0.46);
  }

  // Longer + brighter bell (more partials, longer decay)
  function playBell() {
    ensureAudio();
    const now = audioCtx.currentTime;

    const out = masterGain();
    const mix = audioCtx.createGain();
    mix.gain.value = 1.0;
    mix.connect(out);

    // Brighter bell-ish partials (slightly inharmonic)
    const base = 528; // brighter than 432
    const ratios = [1.0, 2.0, 2.76, 3.12, 4.20, 5.40];
    const amps   = [0.14, 0.09, 0.07, 0.05, 0.035, 0.025];
    const decays = [4.8, 4.0, 3.4, 3.0, 2.6, 2.2];

    ratios.forEach((r, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      // Mix of sine + triangle on upper partials for brightness
      osc.type = (i >= 2) ? "triangle" : "sine";

      const f = base * r;
      osc.frequency.setValueAtTime(f, now);
      osc.detune.setValueAtTime((Math.random() * 10) - 5, now); // subtle shimmer

      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(amps[i], now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + decays[i]);

      osc.connect(gain);
      gain.connect(mix);

      osc.start(now);
      osc.stop(now + decays[i] + 0.12);
    });

    // Slight “strike” noise (a touch longer than before)
    const noiseDur = 0.45;
    const bufferSize = Math.floor(audioCtx.sampleRate * noiseDur);
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.06;

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    const nGain = audioCtx.createGain();
    nGain.gain.setValueAtTime(0.0001, now);
    nGain.gain.exponentialRampToValueAtTime(0.03, now + 0.012);
    nGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);

    noise.connect(nGain);
    nGain.connect(out);
    noise.start(now);
    noise.stop(now + noiseDur);
  }

  function playDoubleBeep() {
    playBeep();
    setTimeout(() => { try { playBeep(); } catch {} }, 500);
  }

  // ---- Timer scheduling ----
  let state = "idle"; // idle | running | done
  let totalSec = 30 * 60;
  let startPerf = 0;
  let rafId = 0;
  let cueTimeouts = [];
  let cuesScaled = []; // {tSec, kind, label}
  let nextCueIndex = 0;

  function clearCues() {
    cueTimeouts.forEach(id => clearTimeout(id));
    cueTimeouts = [];
    nextCueIndex = 0;
  }

  function computeScaledCues(selectedMinutes) {
    const scale = selectedMinutes / TEMPLATE_TOTAL_MIN;

    const cues = templateCues.map(c => ({
      tSec: Math.round(c.tMin * 60 * scale),
      kind: c.kind,
      label: c.label
    }));

    cues[0].tSec = 0;
    cues[cues.length - 1].tSec = selectedMinutes * 60;

    // Keep strictly increasing to avoid rounding collisions
    for (let i = 1; i < cues.length; i++) {
      if (cues[i].tSec <= cues[i - 1].tSec) cues[i].tSec = cues[i - 1].tSec + 1;
    }
    cues[cues.length - 1].tSec = selectedMinutes * 60;
    return cues;
  }

  function renderChips(elapsedSec = 0) {
    chipsEl.innerHTML = "";
    let activeIdx = nextCueIndex;

    // compute next cue index for display
    while (activeIdx < cuesScaled.length && cuesScaled[activeIdx].tSec <= elapsedSec + 0.02) activeIdx++;

    cuesScaled.forEach((c, idx) => {
      const div = document.createElement("div");
      const isActive = (idx === activeIdx && state === "running");
      div.className = "chip" + (isActive ? " active" : "");
      const kindText = c.kind === "bell" ? "Bell" : (c.kind === "double" ? "Two beeps" : "Beep");
      div.innerHTML = `<strong>${kindText}</strong> · ${formatCueTime(c.tSec)}`;
      chipsEl.appendChild(div);
    });
  }

  function setStatus(text) { statusBadge.textContent = text; }

  function setButtons() {
    const running = state === "running";
    startBtn.disabled = running;
    stopBtn.disabled = (state === "idle");
    minutesSel.disabled = running;
  }

  function triggerCue(kind) {
    if (kind === "bell") playBell();
    else if (kind === "double") playDoubleBeep();
    else playBeep();
  }

  function scheduleCues() {
    clearCues();

    const elapsedSec = 0; // at schedule start
    nextCueIndex = 0;

    // Schedule all cues relative to startPerf
    cuesScaled.forEach((cue, idx) => {
      const delayMs = Math.max(0, cue.tSec * 1000);
      const id = setTimeout(() => {
        if (state !== "running") return;

        // Update UI label and play cue
        stageLabel.textContent = cue.label;
        triggerCue(cue.kind);

        // Move pointer and re-render chips
        nextCueIndex = Math.min(cuesScaled.length, idx + 1);
        const nowPerf = performance.now();
        const elapsed = (nowPerf - startPerf) / 1000;
        renderChips(elapsed);

        // End
        if (cue.tSec >= totalSec) finish();
      }, delayMs);

      cueTimeouts.push(id);
    });

    renderChips(elapsedSec);
  }

  function tickUI() {
    const nowPerf = performance.now();
    const elapsedSec = (nowPerf - startPerf) / 1000;
    const remaining = totalSec - elapsedSec;

    timeLeftEl.textContent = mmss(remaining);
    setProgress(elapsedSec / totalSec);
    renderChips(elapsedSec);

    if (state === "running") rafId = requestAnimationFrame(tickUI);
  }

  function start() {
    ensureAudio();

    const selectedMinutes = parseInt(minutesSel.value, 10);
    totalSec = selectedMinutes * 60;
    cuesScaled = computeScaledCues(selectedMinutes);

    state = "running";
    startPerf = performance.now();
    setStatus("Meditating");
    stageLabel.textContent = "Start bell";
    setButtons();

    // Start bell immediately
    triggerCue("bell");

    // Schedule cues (including end bell at total duration)
    scheduleCues();

    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tickUI);
  }

  function stop() {
    clearCues();
    cancelAnimationFrame(rafId);

    state = "idle";
    setStatus("Ready");
    stageLabel.textContent = "Bell at start · Beeps along the way · Bell at end";
    setButtons();
    setProgress(0);

    const selectedMinutes = parseInt(minutesSel.value, 10);
    totalSec = selectedMinutes * 60;
    timeLeftEl.textContent = mmss(totalSec);

    cuesScaled = computeScaledCues(selectedMinutes);
    nextCueIndex = 0;
    renderChips(0);
  }

  function finish() {
    clearCues();
    cancelAnimationFrame(rafId);
    state = "done";
    setStatus("Done");
    stageLabel.textContent = "Session complete";
    setButtons();
    // Let user tap Stop to reset
    startBtn.disabled = true;
  }

  // Initial render
  stop();

  // Events
  startBtn.addEventListener("click", start);
  stopBtn.addEventListener("click", () => {
    // allow resetting even from done state
    startBtn.disabled = false;
    stop();
  });

  minutesSel.addEventListener("change", () => {
    if (state !== "idle") return;
    stop();
  });
})();
</script>
</body>
</html>
